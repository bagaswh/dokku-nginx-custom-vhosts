#!/usr/bin/env bash
set -eo pipefail
[[ $DOKKU_TRACE ]] && set -x
_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$_DIR/config"
source "$PLUGIN_CORE_AVAILABLE_PATH/common/functions"
source "$PLUGIN_AVAILABLE_PATH/certs/functions"
source "$PLUGIN_AVAILABLE_PATH/config/functions"
source "$_DIR/internal-functions"

get_nginx_location() {
  declare desc="check that nginx is at the expected location and return it"
  fn-nginx-custom-nginx-custom-location
}

get_app_proxy_type() {
  local APP="$1"
  plugn trigger proxy-type "$APP"
}

validate_nginx() {
  declare desc="validate entire nginx config"
  declare APP="${1:-}" FLAG="${2:-}"
  local NGINX_LOCATION EXIT_CODE
  NGINX_LOCATION=$(get_nginx_location)
  if [[ -z "$NGINX_LOCATION" ]]; then
    exit 1
  fi

  if [[ "$APP" == "--clean" ]]; then
    APP=""
    FLAG="--clean"
  fi

  set +e
  sudo "$NGINX_LOCATION" -t &>/dev/null
  EXIT_CODE=$?
  set -e
  if [[ "$EXIT_CODE" -eq "0" ]]; then
    return
  fi

  if [[ -n "$APP" ]]; then
    verify_app_name "$APP"
    nginx_vhosts_validate_single_func "$APP" "$FLAG"
  else
    for app in $(dokku_apps "false"); do
      nginx_vhosts_validate_single_func "$app" "$FLAG"
    done
  fi

  set +e
  sudo "$NGINX_LOCATION" -t &>/dev/null
  EXIT_CODE=$?
  set -e
  if [[ "$EXIT_CODE" -eq "0" ]]; then
    return
  fi

  sudo "$NGINX_LOCATION" -t
  exit $?
}

restart_nginx() {
  declare desc="restart nginx for given distros"
  local PROXY_ENABLED="$(plugn trigger proxy-is-enabled "$APP")"
  local PROXY_TYPE="$(plugn trigger proxy-type "$APP")"
  if [[ "$PROXY_ENABLED" == "true" ]] && [[ "$PROXY_TYPE" == "$PROXY_NAME" ]]; then
    fn-nginx-custom-nginx-custom-init-cmd "reload"
  fi
}

nginx_logs() {
  declare desc="display app nginx logs"
  declare CMD="$1" APP="$2"
  local log_type

  if [[ "$CMD" == *"access-logs"* ]]; then
    log_type="access"
  elif [[ "$CMD" == *"error-logs"* ]]; then
    log_type="error"
  else
    dokku_log_fail "Unknown log type from command: $CMD"
    return 1
  fi

  local NGINX_LOGS_PATH
  NGINX_LOGS_PATH=$(fn-nginx-custom-computed-${log_type}-log-path "$APP")

  if [[ "$NGINX_LOGS_PATH" == "off" ]] || [[ "$NGINX_LOGS_PATH" == "/dev/null" ]] || [[ -z "$NGINX_LOGS_PATH" ]]; then
    dokku_log_fail "${log_type} logs are disabled or path not found for this app"
    return 1
  fi

  local tail=false
  local num=20
  if [[ $3 == "-t" ]]; then
    tail=true
  fi

  local DOKKU_SCHEDULER
  DOKKU_SCHEDULER=$(get_app_scheduler "$APP")
  if [[ "$DOKKU_SCHEDULER" != "docker-local" ]] && [[ "$DOKKU_SCHEDULER" != "null" ]]; then
    plugn trigger scheduler-proxy-logs "$DOKKU_SCHEDULER" "$APP" "$PROXY_NAME" "$log_type" "$tail" "$num"
    return $?
  fi

  if [[ "$tail" == "true" ]]; then
    tail -F "$NGINX_LOGS_PATH"
  else
    tail -n "$num" "$NGINX_LOGS_PATH"
  fi
}

validate_ssl_domains() {
  declare desc="check configured domains against SSL cert contents and show warning if mismatched"
  local APP=$1
  local VHOST_PATH="$DOKKU_ROOT/$APP/VHOST"
  local SSL_HOSTNAME=$(get_ssl_hostnames "$APP")
  local SSL_HOSTNAME_REGEX=$(echo "$SSL_HOSTNAME" | xargs | sed 's|\.|\\.|g' | sed 's/\*/\[^\.\]\*/g' | sed 's/ /|/g')

  if ! (grep -q -E "^${SSL_HOSTNAME_REGEX}$" "$VHOST_PATH" &>/dev/null); then
    dokku_log_info1 "No matching configured domains for $APP found in SSL certificate. Your app will show as insecure in a browser if accessed via SSL"
    dokku_log_info1 "Please add appropriate domains via the dokku domains command"
    [[ -n "$NONSSL_VHOSTS" ]] && dokku_log_info1 "Configured domains for app:"
    local domain
    for domain in $(echo "$NONSSL_VHOSTS" | xargs); do
      dokku_log_info2 "$domain"
    done
    [[ -n "$SSL_HOSTNAME" ]] && dokku_log_info1 "Domains found in SSL certificate:"
    for domain in $(echo "$SSL_HOSTNAME" | xargs); do
      dokku_log_info2 "$domain"
    done
  fi
}

get_custom_nginx_template() {
  declare desc="attempts to copy custom nginx template from app image"
  local APP="$1"
  local DESTINATION_FILE="$2"
  local DISABLE_CUSTOM_CONFIG
  DISABLE_CUSTOM_CONFIG="$(fn-nginx-custom-computed-disable-custom-config "$APP")"

  if [[ "$DISABLE_CUSTOM_CONFIG" == "true" ]]; then
    return 1
  fi

  local custom_template_with_pid="${DOKKU_LIB_ROOT}/data/$PROXY_NAME/app-$APP/nginx.conf.sigil.$DOKKU_PID"
  local custom_template_generic="${DOKKU_LIB_ROOT}/data/$PROXY_NAME/app-$APP/nginx.conf.sigil"

  if [[ -f "$custom_template_with_pid" ]]; then
    cp "$custom_template_with_pid" "$DESTINATION_FILE"
    return 0
  elif [[ -f "$custom_template_generic" ]]; then
    cp "$custom_template_generic" "$DESTINATION_FILE"
    return 0
  fi

  return 1
}

is_tls13_available() {
  declare desc="detects whether the installed nginx version has TLSv1.3 support"
  local NGINX_VERSION="$1"
  local MAJOR_VERSION MINOR_VERSION PATCH_VERSION
  local HAS_SUPPORT=false

  MAJOR_VERSION=$(echo "$NGINX_VERSION" | awk '{split($0,a,"."); print a[1]}')
  MINOR_VERSION=$(echo "$NGINX_VERSION" | awk '{split($0,a,"."); print a[2]}')
  PATCH_VERSION=$(echo "$NGINX_VERSION" | awk '{split($0,a,"."); print a[3]}')
  if [[ "$MAJOR_VERSION" -ge "2" ]]; then
    HAS_SUPPORT=true
  elif [[ "$MAJOR_VERSION" -eq "1" ]] && [[ "$MINOR_VERSION" -ge "13" ]]; then
    HAS_SUPPORT=true
  fi

  echo $HAS_SUPPORT
}

is_http2_push_enabled() {
  declare desc="detects whether the installed nginx version has http2 push support"
  local NGINX_VERSION="$1"
  local MAJOR_VERSION MINOR_VERSION PATCH_VERSION
  local HAS_SUPPORT=false

  MAJOR_VERSION=$(echo "$NGINX_VERSION" | awk '{split($0,a,"."); print a[1]}')
  MINOR_VERSION=$(echo "$NGINX_VERSION" | awk '{split($0,a,"."); print a[2]}')
  PATCH_VERSION=$(echo "$NGINX_VERSION" | awk '{split($0,a,"."); print a[3]}')
  if [[ "$MAJOR_VERSION" -ge "2" ]]; then
    HAS_SUPPORT=true
  elif [[ "$MAJOR_VERSION" -eq "1" ]]; then
    if [[ "$MINOR_VERSION" -eq "13" ]] && [[ "$PATCH_VERSION" -ge "9" ]]; then
      HAS_SUPPORT=true
    elif [[ "$MINOR_VERSION" -ge "14" ]]; then
      HAS_SUPPORT=true
    fi
  fi

  echo $HAS_SUPPORT
}

is_http2_enabled() {
  declare desc="detects whether the installed nginx version has http2 support"
  local NGINX_VERSION="$1"
  local MAJOR_VERSION MINOR_VERSION PATCH_VERSION
  local HAS_SUPPORT=false

  MAJOR_VERSION=$(echo "$NGINX_VERSION" | awk '{split($0,a,"."); print a[1]}')
  MINOR_VERSION=$(echo "$NGINX_VERSION" | awk '{split($0,a,"."); print a[2]}')
  PATCH_VERSION=$(echo "$NGINX_VERSION" | awk '{split($0,a,"."); print a[3]}')
  if [[ "$MAJOR_VERSION" -ge "2" ]]; then
    HAS_SUPPORT=true
  elif [[ "$MAJOR_VERSION" -eq "1" ]]; then
    if [[ "$MINOR_VERSION" -eq "11" ]] && [[ "$PATCH_VERSION" -ge "5" ]]; then
      HAS_SUPPORT=true
    elif [[ "$MINOR_VERSION" -ge "12" ]]; then
      HAS_SUPPORT=true
    fi
  fi

  echo $HAS_SUPPORT
}

is_grpc_enabled() {
  declare desc="detects whether the installed nginx version has grpc support"
  local NGINX_VERSION="$1"
  local MAJOR_VERSION MINOR_VERSION PATCH_VERSION
  local HAS_SUPPORT=false

  MAJOR_VERSION=$(echo "$NGINX_VERSION" | awk '{split($0,a,"."); print a[1]}')
  MINOR_VERSION=$(echo "$NGINX_VERSION" | awk '{split($0,a,"."); print a[2]}')
  PATCH_VERSION=$(echo "$NGINX_VERSION" | awk '{split($0,a,"."); print a[3]}')
  if [[ "$MAJOR_VERSION" -ge "2" ]]; then
    HAS_SUPPORT=true
  elif [[ "$MAJOR_VERSION" -eq "1" ]]; then
    if [[ "$MINOR_VERSION" -eq "13" ]] && [[ "$PATCH_VERSION" -ge "10" ]]; then
      HAS_SUPPORT=true
    elif [[ "$MINOR_VERSION" -ge "14" ]]; then
      HAS_SUPPORT=true
    fi
  fi

  echo $HAS_SUPPORT
}

# nginx_build_config() {
#   declare desc="build nginx config to proxy app containers using sigil"
#   declare APP="$1" DOKKU_APP_LISTEN_PORT="$2" DOKKU_APP_LISTEN_IP="$3"
#   local APP_PATH ROOT_DOMAIN DEFAULT_APP VHOST_PATH NGINX_TEMPLATE_NAME NGINX_TEMPLATE SCHEME NGINX_TEMPLATE_SOURCE APP_SSL_PATH DOKKU_APP_LISTENERS
#   local IS_APP_VHOST_ENABLED IS_SSL_ENABLED PROXY_PORT PROXY_SSL_PORT PORT_MAP PROXY_PORT_MAP proxy_port_map PROXY_UPSTREAM_PORTS
#   local SSL_INUSE NONSSL_VHOSTS NOSSL_SERVER_NAME SSL_HOSTNAME SSL_HOSTNAME_REGEX SSL_VHOSTS SSL_SERVER_NAME host
#   local NGINX_LOCATION NGINX_VERSION SPDY_SUPPORTED TLS13_SUPPORTED HTTP2_SUPPORTED HTTP2_PUSH_SUPPORTED GRPC_SUPPORTED
#   local NGINX_LOG_ROOT NGINX_ACCESS_LOG_FORMAT NGINX_ACCESS_LOG_PATH NGINX_ERROR_LOG_PATH
#   local CLIENT_BODY_TIMEOUT CLIENT_HEADER_TIMEOUT CLIENT_MAX_BODY_SIZE KEEPALIVE_TIMEOUT LINGERING_TIMEOUT
#   local PROXY_CONNECT_TIMEOUT PROXY_READ_TIMEOUT PROXY_SEND_TIMEOUT SEND_TIMEOUT
#   local PROXY_BUFFER_SIZE PROXY_BUFFERING PROXY_BUFFERS PROXY_BUSY_BUFFERS_SIZE
#   local IMAGE_TAG IMAGE NGINX_BUILD_CONFIG_TMP_WORK_DIR NGINX_CONF CUSTOM_NGINX_TEMPLATE
#   local NGINX_BIND_ADDRESS_IP4 NGINX_BIND_ADDRESS_IP6 NGINX_UNDERSCORE_IN_HEADERS
#   local PROXY_X_FORWARDED_FOR PROXY_X_FORWARDED_PORT PROXY_X_FORWARDED_PROTO PROXY_X_FORWARDED_SSL
#   local ALL_APPS_FOR_DOMAIN PRIMARY_APP_FOR_DOMAIN STRIP_PATH SIGIL_PARAMS PROC_TYPE LISTENERS UPP_PROC_TYPE

#   if [[ "$(plugn trigger proxy-is-enabled "$APP")" != "true" ]]; then
#     dokku_log_info1 "Nginx support is disabled for app ($APP)"
#     if [[ -f "$DOKKU_ROOT/$APP/nginx.conf" ]]; then
#       dokku_log_info1 "Deleting nginx.conf for $APP"
#       rm -f "$DOKKU_ROOT/$APP/nginx.conf"
#       rm -rf "$DOKKU_ROOT/$APP/nginx.conf.d"
#       validate_nginx && restart_nginx >/dev/null
#     fi
#     return
#   fi

#   ROOT_DOMAIN="$(fn-nginx-custom-computed-root-domain "$APP")"

#   if [[ -z "$ROOT_DOMAIN" ]]; then
#     ROOT_DOMAIN="$APP"
#     dokku_log_info2 "No root domain configured, using app name: $ROOT_DOMAIN"
#   fi

#   ALL_APPS_FOR_DOMAIN=""
#   for app_check in $(dokku_apps); do
#     local app_check_root_domain="$(fn-nginx-custom-computed-root-domain "$app_check")"
#     # Fallback
#     if [[ -z "$app_check_root_domain" ]]; then
#       app_check_root_domain="$app_check"
#     fi

#     if [[ "$app_check_root_domain" == "$ROOT_DOMAIN" ]] && [[ "$(plugn trigger proxy-is-enabled "$app_check")" == "true" ]]; then
#       ALL_APPS_FOR_DOMAIN="$ALL_APPS_FOR_DOMAIN $app_check"
#     fi
#   done
#   ALL_APPS_FOR_DOMAIN=$(echo "$ALL_APPS_FOR_DOMAIN" | xargs)

#   PRIMARY_APP_FOR_DOMAIN=""

#   for app_check in $ALL_APPS_FOR_DOMAIN; do
#     local explicit_default="$(fn-nginx-custom-computed-default-app "$app_check")"
#     if [[ -n "$explicit_default" ]] && [[ "$explicit_default" == "$app_check" ]]; then
#       PRIMARY_APP_FOR_DOMAIN="$app_check"
#       dokku_log_info2 "Found explicit default app: $PRIMARY_APP_FOR_DOMAIN"
#       break
#     fi
#   done

#   if [[ -z "$PRIMARY_APP_FOR_DOMAIN" ]]; then
#     PRIMARY_APP_FOR_DOMAIN="$(echo "$ALL_APPS_FOR_DOMAIN" | tr ' ' '\n' | sort | head -1)"
#     dokku_log_info2 "No explicit default app found for domain '$ROOT_DOMAIN'. Using alphabetically first app: '$PRIMARY_APP_FOR_DOMAIN'"
#   fi

#   if [[ "$APP" != "$PRIMARY_APP_FOR_DOMAIN" ]]; then
#     dokku_log_info2 "Domain $ROOT_DOMAIN is managed by $PRIMARY_APP_FOR_DOMAIN. Building its config instead..."
#     nginx_build_config "$PRIMARY_APP_FOR_DOMAIN" "$DOKKU_APP_LISTEN_PORT" "$DOKKU_APP_LISTEN_IP"
#     return
#   fi

#   dokku_log_info1 "Creating primary configuration for domain $ROOT_DOMAIN (managed by $APP)..."

#   NGINX_BUILD_CONFIG_TMP_WORK_DIR=$(mktemp -d "/tmp/dokku-${DOKKU_PID}-${FUNCNAME[0]}.XXXXXX")
#   trap "rm -rf '$NGINX_BUILD_CONFIG_TMP_WORK_DIR' >/dev/null" RETURN INT TERM EXIT

#   rm -f "$DOKKU_ROOT/$APP/nginx.conf.d/"*.conf 2>/dev/null || true

#   mkdir -p "$DOKKU_ROOT/$APP/nginx.conf.d"

#   for other_app in $ALL_APPS_FOR_DOMAIN; do
#     if [[ "$other_app" != "$APP" ]]; then
#       dokku_log_info2 "Merging config for $other_app..."
#       local other_app_path="$(fn-nginx-custom-computed-app-path "$other_app")"
#       local other_upstream_ports=""

#       while read -r PORT_MAP; do
#         if [[ -n "$PORT_MAP" ]]; then
#           local other_upstream_port="$(awk -F ':' '{ print $3 }' <<<"$PORT_MAP")"
#           other_upstream_ports="$other_upstream_ports $other_upstream_port"
#         fi
#       done < <(plugn trigger ports-get "$other_app" 2>/dev/null || echo "http:80:5000")
#       other_upstream_ports="$(echo "$other_upstream_ports" | xargs)"

#       if [[ -z "$other_upstream_ports" ]]; then
#         other_upstream_ports="5000"
#       fi

#       generate_location_config_for_app "$other_app" "$other_app_path" "$other_upstream_ports" "$NGINX_BUILD_CONFIG_TMP_WORK_DIR" > "$DOKKU_ROOT/$APP/nginx.conf.d/location-${other_app}.conf"
#       generate_upstream_config_for_app "$other_app" "$other_upstream_ports" > "$DOKKU_ROOT/$APP/nginx.conf.d/upstream-${other_app}.conf"
#     fi
#   done

#   for other_app in $ALL_APPS_FOR_DOMAIN; do
#     if [[ "$other_app" != "$APP" ]] && [[ -f "$DOKKU_ROOT/$other_app/nginx.conf" ]]; then
#       dokku_log_info2 "Deleting conflicting nginx.conf from secondary app $other_app"
#       rm -f "$DOKKU_ROOT/$other_app/nginx.conf"
#       rm -rf "$DOKKU_ROOT/$other_app/nginx.conf.d"
#     fi
#   done

#   APP_PATH="$(fn-nginx-custom-computed-app-path "$APP")"
#   DEFAULT_APP="$PRIMARY_APP_FOR_DOMAIN"
#   VHOST_PATH="$DOKKU_ROOT/$APP/VHOST"
#   NGINX_TEMPLATE_NAME="nginx.conf.sigil"
#   NGINX_TEMPLATE="$_DIR/templates/$NGINX_TEMPLATE_NAME"
#   SCHEME=http
#   NGINX_TEMPLATE_SOURCE="built-in"
#   APP_SSL_PATH="$DOKKU_ROOT/$APP/tls"

#   IS_APP_VHOST_ENABLED=true
#   plugn trigger domains-vhost-enabled "$APP" 2>/dev/null || IS_APP_VHOST_ENABLED=false

#   IS_SSL_ENABLED=false
#   if [[ "$(plugn trigger certs-exists "$APP")" == "true" ]]; then
#     IS_SSL_ENABLED=true
#   fi

#   if [[ -z "$DOKKU_APP_LISTEN_PORT" ]] && [[ -z "$DOKKU_APP_LISTEN_IP" ]]; then
#     DOKKU_APP_LISTENERS="$(plugn trigger network-get-listeners "$APP" "web" 2>/dev/null | xargs || true)"

#     if [[ -z "$DOKKU_APP_LISTENERS" ]]; then
#       dokku_log_info2 "No network listeners found, trying to detect from running containers..."

#       local container_listeners=""
#       while read -r container_ip; do
#         if [[ -n "$container_ip" ]]; then
#           container_listeners="$container_listeners $container_ip:5000"
#         fi
#       done < <(docker ps --filter "label=com.dokku.app-name=$APP" --format "{{.Names}}" 2>/dev/null | head -5 | while read -r container_name; do
#         docker inspect "$container_name" --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' 2>/dev/null || true
#       done)

#       if [[ -n "$container_listeners" ]]; then
#         DOKKU_APP_LISTENERS="$(echo "$container_listeners" | xargs)"
#         dokku_log_info2 "Detected container listeners: $DOKKU_APP_LISTENERS"
#       fi
#     fi

#     if [[ -z "$DOKKU_APP_LISTENERS" ]]; then
#       dokku_log_info2 "No listeners detected, using default fallback"
#       DOKKU_APP_LISTENERS="172.17.0.1:5000"
#     fi

#   elif [[ -n "$DOKKU_APP_LISTEN_PORT" ]] && [[ -n "$DOKKU_APP_LISTEN_IP" ]]; then
#     local PASSED_LISTEN_IP_PORT=true
#     DOKKU_APP_LISTENERS="$DOKKU_APP_LISTEN_IP:$DOKKU_APP_LISTEN_PORT"
#   fi

#   plugn trigger ports-configure "$APP" 2>/dev/null || true
#   PROXY_PORT=$(config_get "$APP" DOKKU_PROXY_PORT || echo "80")
#   PROXY_SSL_PORT=$(config_get "$APP" DOKKU_PROXY_SSL_PORT || echo "443")

#   proxy_port_map=""
#   PROXY_UPSTREAM_PORTS=""

#   while read -r PORT_MAP; do
#     if [[ -n "$PORT_MAP" ]]; then
#       local PROXY_UPSTREAM_SCHEME="$(awk -F ':' '{ print $1 }' <<<"$PORT_MAP")"
#       if [[ "$PROXY_UPSTREAM_SCHEME" == "https" ]] && [[ "$IS_SSL_ENABLED" == "false" ]]; then
#         dokku_log_warn "Ignoring detected https port mapping without an accompanying ssl certificate (${PORT_MAP})"
#         continue
#       fi
#       proxy_port_map="$proxy_port_map $PORT_MAP"
#       local PROXY_UPSTREAM_PORT="$(awk -F ':' '{ print $3 }' <<<"$PORT_MAP")"
#       if [[ "$(is_val_in_list "$PROXY_UPSTREAM_PORT" "$PROXY_UPSTREAM_PORTS" " ")" == "false" ]]; then
#         PROXY_UPSTREAM_PORTS+="$PROXY_UPSTREAM_PORT "
#       fi
#     fi
#   done < <(plugn trigger ports-get "$APP" 2>/dev/null || echo "http:80:5000")

#   PROXY_PORT_MAP="$(echo "$proxy_port_map" | xargs)"
#   PROXY_UPSTREAM_PORTS="$(echo "$PROXY_UPSTREAM_PORTS" | xargs)"

#   if [[ -z "$PROXY_UPSTREAM_PORTS" ]]; then
#     dokku_log_info2 "No upstream ports detected, using default port 5000"
#     PROXY_UPSTREAM_PORTS="5000"
#     PROXY_PORT_MAP="http:80:5000"
#   fi

#   SSL_INUSE=""
#   NONSSL_VHOSTS=$(plugn trigger domains-list "$APP" 2>/dev/null || echo "$ROOT_DOMAIN")
#   NOSSL_SERVER_NAME=$(echo "$NONSSL_VHOSTS" | xargs)
#   if [[ "$IS_SSL_ENABLED" == "true" ]]; then
#     SSL_INUSE=true
#     SCHEME=https
#     validate_ssl_domains "$APP"
#     SSL_HOSTNAME=$(get_ssl_hostnames "$APP")
#     SSL_HOSTNAME_REGEX=$(echo "$SSL_HOSTNAME" | xargs | sed 's|\.|\\.|g' | sed 's/\*/\[^\.\]\*/g' | sed 's/ /|/g')
#     if [[ "$IS_APP_VHOST_ENABLED" == "true" ]]; then
#       SSL_VHOSTS=$(grep -E "^${SSL_HOSTNAME_REGEX}$" "$VHOST_PATH" 2>/dev/null || true)
#     else
#       SSL_VHOSTS=$(<"$DOKKU_ROOT/VHOST" 2>/dev/null || echo "$ROOT_DOMAIN")
#     fi
#     for host in $SSL_VHOSTS; do
#       if [[ ! $NOSSL_SERVER_NAME =~ (^|[[:space:]])$host($|[[:space:]]) ]]; then
#         SSL_SERVER_NAME="${host}${SSL_SERVER_NAME:+ $SSL_SERVER_NAME}"
#       fi
#     done
#   fi

#   NGINX_LOCATION=$(get_nginx_location)
#   if [[ -z "$NGINX_LOCATION" ]]; then
#     dokku_log_fail "Could not find nginx binary"
#     exit 1
#   fi
#   NGINX_VERSION="$("$NGINX_LOCATION" -v 2>&1 | cut -d'/' -f 2)"
#   SPDY_SUPPORTED="false"
#   TLS13_SUPPORTED="$(is_tls13_available "$NGINX_VERSION")"
#   HTTP2_SUPPORTED="$(is_http2_enabled "$NGINX_VERSION")"
#   HTTP2_PUSH_SUPPORTED="$(is_http2_push_enabled "$NGINX_VERSION")"
#   GRPC_SUPPORTED="$(is_grpc_enabled "$NGINX_VERSION")"

#   NGINX_LOG_ROOT="$(fn-nginx-custom-log-root)"
#   NGINX_ACCESS_LOG_FORMAT="$(fn-nginx-custom-computed-access-log-format "$APP")"
#   NGINX_ACCESS_LOG_PATH="$(fn-nginx-custom-computed-access-log-path "$APP")"
#   NGINX_ERROR_LOG_PATH="$(fn-nginx-custom-computed-error-log-path "$APP")"
#   CLIENT_BODY_TIMEOUT="$(fn-nginx-custom-computed-client-body-timeout "$APP")"
#   CLIENT_HEADER_TIMEOUT="$(fn-nginx-custom-computed-client-header-timeout "$APP")"
#   CLIENT_MAX_BODY_SIZE="$(fn-nginx-custom-computed-client-max-body-size "$APP")"
#   KEEPALIVE_TIMEOUT="$(fn-nginx-custom-computed-keepalive-timeout "$APP")"
#   LINGERING_TIMEOUT="$(fn-nginx-custom-computed-lingering-timeout "$APP")"
#   PROXY_CONNECT_TIMEOUT="$(fn-nginx-custom-computed-proxy-connect-timeout "$APP")"
#   PROXY_READ_TIMEOUT="$(fn-nginx-custom-computed-proxy-read-timeout "$APP")"
#   PROXY_SEND_TIMEOUT="$(fn-nginx-custom-computed-proxy-send-timeout "$APP")"
#   SEND_TIMEOUT="$(fn-nginx-custom-computed-send-timeout "$APP")"
#   PROXY_BUFFER_SIZE="$(fn-nginx-custom-computed-proxy-buffer-size "$APP")"
#   PROXY_BUFFERING="$(fn-nginx-custom-computed-proxy-buffering "$APP")"
#   PROXY_BUFFERS="$(fn-nginx-custom-computed-proxy-buffers "$APP")"
#   PROXY_BUSY_BUFFERS_SIZE="$(fn-nginx-custom-computed-proxy-busy-buffers-size "$APP")"

#   dokku_log_info2 "Using listeners: $DOKKU_APP_LISTENERS"
#   dokku_log_info2 "Using upstream ports: $PROXY_UPSTREAM_PORTS"
#   dokku_log_info2 "Using port map: $PROXY_PORT_MAP"

#   if ! (is_deployed "$APP" 2>/dev/null); then
#     dokku_log_warn_quiet "App $APP may not be fully deployed, but generating nginx config anyway"
#   fi

#   NGINX_CONF=$(mktemp --tmpdir="${NGINX_BUILD_CONFIG_TMP_WORK_DIR}" "nginx.conf.XXXXXX")
#   CUSTOM_NGINX_TEMPLATE="$NGINX_BUILD_CONFIG_TMP_WORK_DIR/$NGINX_TEMPLATE_NAME"

#   if get_custom_nginx_template "$APP" "$CUSTOM_NGINX_TEMPLATE"; then
#     dokku_log_info1 'Overriding default nginx.conf with detected nginx.conf.sigil'
#     NGINX_TEMPLATE="$CUSTOM_NGINX_TEMPLATE"
#     NGINX_TEMPLATE_SOURCE="app-supplied"
#   else
#     dokku_log_info2 'No custom nginx.conf.sigil found, using built-in template.'
#     NGINX_TEMPLATE="$_DIR/templates/$NGINX_TEMPLATE_NAME"
#     NGINX_TEMPLATE_SOURCE="built-in"
#   fi

#   if [[ -z "$NGINX_TEMPLATE" ]] || [[ ! -f "$NGINX_TEMPLATE" ]]; then
#     dokku_log_fail "FATAL: Nginx template could not be found."
#     return 1
#   fi

#   NGINX_BIND_ADDRESS_IP4="$(fn-nginx-custom-computed-bind-address-ipv4 "$APP")"
#   NGINX_BIND_ADDRESS_IP6="$(fn-nginx-custom-computed-bind-address-ipv6 "$APP")"
#   NGINX_UNDERSCORE_IN_HEADERS="$(fn-nginx-custom-computed-underscore-in-headers "$APP")"
#   PROXY_X_FORWARDED_FOR="$(fn-nginx-custom-computed-x-forwarded-for-value "$APP")"
#   PROXY_X_FORWARDED_PORT="$(fn-nginx-custom-computed-x-forwarded-port-value "$APP")"
#   PROXY_X_FORWARDED_PROTO="$(fn-nginx-custom-computed-x-forwarded-proto-value "$APP")"
#   PROXY_X_FORWARDED_SSL="$(fn-nginx-custom-computed-x-forwarded-ssl "$APP")"

#   STRIP_PATH="$(fn-nginx-custom-computed-strip-path "$APP")"

#   eval "$(config_export app "$APP" 2>/dev/null || true)"
#   SIGIL_PARAMS=(-f "$NGINX_TEMPLATE" APP="$APP" DOKKU_ROOT="$DOKKU_ROOT"
#     NOSSL_SERVER_NAME="$NOSSL_SERVER_NAME"
#     DOKKU_APP_LISTENERS="$DOKKU_APP_LISTENERS"
#     DOKKU_LIB_ROOT="$DOKKU_LIB_ROOT"
#     PASSED_LISTEN_IP_PORT="${PASSED_LISTEN_IP_PORT:-}"
#     SPDY_SUPPORTED="$SPDY_SUPPORTED"
#     TLS13_SUPPORTED="$TLS13_SUPPORTED"
#     HTTP2_SUPPORTED="$HTTP2_SUPPORTED"
#     NGINX_LOG_ROOT="$NGINX_LOG_ROOT"
#     NGINX_ACCESS_LOG_FORMAT="$NGINX_ACCESS_LOG_FORMAT"
#     NGINX_ACCESS_LOG_PATH="$NGINX_ACCESS_LOG_PATH"
#     NGINX_ERROR_LOG_PATH="$NGINX_ERROR_LOG_PATH"
#     NGINX_BIND_ADDRESS_IP4="$NGINX_BIND_ADDRESS_IP4"
#     NGINX_BIND_ADDRESS_IP6="$NGINX_BIND_ADDRESS_IP6"
#     HTTP2_PUSH_SUPPORTED="$HTTP2_PUSH_SUPPORTED"
#     GRPC_SUPPORTED="$GRPC_SUPPORTED"
#     DOKKU_APP_LISTEN_PORT="$DOKKU_APP_LISTEN_PORT" DOKKU_APP_LISTEN_IP="$DOKKU_APP_LISTEN_IP"
#     APP_SSL_PATH="$APP_SSL_PATH" SSL_INUSE="$SSL_INUSE" SSL_SERVER_NAME="$SSL_SERVER_NAME"
#     CLIENT_BODY_TIMEOUT="$CLIENT_BODY_TIMEOUT"
#     CLIENT_HEADER_TIMEOUT="$CLIENT_HEADER_TIMEOUT"
#     CLIENT_MAX_BODY_SIZE="$CLIENT_MAX_BODY_SIZE"
#     KEEPALIVE_TIMEOUT="$KEEPALIVE_TIMEOUT"
#     LINGERING_TIMEOUT="$LINGERING_TIMEOUT"
#     PROXY_CONNECT_TIMEOUT="$PROXY_CONNECT_TIMEOUT"
#     PROXY_READ_TIMEOUT="$PROXY_READ_TIMEOUT"
#     PROXY_SEND_TIMEOUT="$PROXY_SEND_TIMEOUT"
#     SEND_TIMEOUT="$SEND_TIMEOUT"
#     PROXY_BUFFER_SIZE="$PROXY_BUFFER_SIZE"
#     PROXY_BUFFERING="$PROXY_BUFFERING"
#     PROXY_BUFFERS="$PROXY_BUFFERS"
#     PROXY_BUSY_BUFFERS_SIZE="$PROXY_BUSY_BUFFERS_SIZE"
#     NGINX_UNDERSCORE_IN_HEADERS="$NGINX_UNDERSCORE_IN_HEADERS"
#     NGINX_PORT="$PROXY_PORT" NGINX_SSL_PORT="$PROXY_SSL_PORT"
#     PROXY_PORT="$PROXY_PORT" PROXY_SSL_PORT="$PROXY_SSL_PORT"
#     PROXY_PORT_MAP="$PROXY_PORT_MAP" PROXY_UPSTREAM_PORTS="$PROXY_UPSTREAM_PORTS"
#     PROXY_X_FORWARDED_FOR="$PROXY_X_FORWARDED_FOR"
#     PROXY_X_FORWARDED_PORT="$PROXY_X_FORWARDED_PORT"
#     PROXY_X_FORWARDED_PROTO="$PROXY_X_FORWARDED_PROTO"
#     PROXY_X_FORWARDED_SSL="$PROXY_X_FORWARDED_SSL"
#     APP_PATH="$APP_PATH"
#     ROOT_DOMAIN="$ROOT_DOMAIN"
#     DEFAULT_APP="$DEFAULT_APP"
#     STRIP_PATH="$STRIP_PATH")

#   while read -r line || [[ -n "$line" ]]; do
#     if [[ -n "$line" ]]; then
#       PROC_TYPE=${line%%=*}
#       LISTENERS="$(plugn trigger network-get-listeners "$APP" "$PROC_TYPE" 2>/dev/null | xargs || true)"
#       UPP_PROC_TYPE="${PROC_TYPE^^}"
#       UPP_PROC_TYPE="${UPP_PROC_TYPE//-/_}"
#       SIGIL_PARAMS+=("DOKKU_APP_${UPP_PROC_TYPE}_LISTENERS=$LISTENERS")
#     fi
#   done < <(plugn trigger ps-current-scale "$APP" 2>/dev/null || echo "web=1")

#   xargs -i echo "-----> Configuring {}...(using $NGINX_TEMPLATE_SOURCE template)" <<<"$(echo "${SSL_VHOSTS:-}" "${NONSSL_VHOSTS}" | tr ' ' '\n' | sort -u)"

#   dokku_log_info2 "Generating nginx configuration..."
#   if ! sigil "${SIGIL_PARAMS[@]}" | cat -s >"$NGINX_CONF"; then
#     dokku_log_fail "Failed to generate nginx configuration using sigil"
#     return 1
#   fi

#   dokku_log_info1 "Creating $SCHEME nginx.conf for $APP"
#   set -x
#   mv "$NGINX_CONF" "$DOKKU_ROOT/$APP/nginx.conf"
#   set +x

#   fn-nginx-custom-manage-hsts "$APP" "$SSL_INUSE"
#   plugn trigger nginx-custom-pre-reload "$APP" "$DOKKU_APP_LISTEN_PORT" "$DOKKU_APP_LISTEN_IP" 2>/dev/null || true

#   dokku_log_verbose "Reloading nginx-custom"
#   validate_nginx && restart_nginx >/dev/null
# }

nginx_build_config() {
  "$_DIR/nginx-config-builder" "$@"
}

generate_location_config_for_app() {
  local app="$1"
  local app_path="$2"
  local upstream_ports="$3"
  local work_dir="$4"

  local strip_path="$(fn-nginx-custom-computed-strip-path "$app")"
  local proxy_connect_timeout="$(fn-nginx-custom-computed-proxy-connect-timeout "$app")"
  local proxy_read_timeout="$(fn-nginx-custom-computed-proxy-read-timeout "$app")"
  local proxy_send_timeout="$(fn-nginx-custom-computed-proxy-send-timeout "$app")"
  local proxy_buffer_size="$(fn-nginx-custom-computed-proxy-buffer-size "$app")"
  local proxy_buffering="$(fn-nginx-custom-computed-proxy-buffering "$app")"
  local proxy_buffers="$(fn-nginx-custom-computed-proxy-buffers "$app")"
  local proxy_busy_buffers_size="$(fn-nginx-custom-computed-proxy-busy-buffers-size "$app")"
  local proxy_x_forwarded_for="$(fn-nginx-custom-computed-x-forwarded-for-value "$app")"
  local proxy_x_forwarded_port="$(fn-nginx-custom-computed-x-forwarded-port-value "$app")"
  local proxy_x_forwarded_proto="$(fn-nginx-custom-computed-x-forwarded-proto-value "$app")"
  local proxy_x_forwarded_ssl="$(fn-nginx-custom-computed-x-forwarded-ssl "$app")"

  if [[ -z "$upstream_ports" ]]; then
    upstream_ports="5000"
  fi

  for upstream_port in $upstream_ports; do
    cat <<EOF
# Location block for app: $app
location /${app_path}/ {
$(if [[ "$strip_path" == "true" ]]; then
cat <<EOL
    rewrite "^/${app_path}/(.*)" "/\$1" break;
    proxy_pass http://${app}-${upstream_port}/;
EOL
else
cat <<EOL
    # Keep the original path
    proxy_pass http://${app}-${upstream_port}/;
EOL
fi)

    gzip on;
    gzip_min_length  1100;
    gzip_buffers  4 32k;
    gzip_types    text/css text/javascript text/xml text/plain text/x-component application/javascript application/x-javascript application/wasm application/json application/xml application/rss+xml font/truetype application/x-font-ttf font/opentype application/vnd.ms-fontobject image/svg+xml;
    gzip_vary on;
    gzip_comp_level  6;

    proxy_http_version 1.1;
$(if [[ -n "$proxy_connect_timeout" ]]; then echo "    proxy_connect_timeout $proxy_connect_timeout;"; fi)
$(if [[ -n "$proxy_read_timeout" ]]; then echo "    proxy_read_timeout $proxy_read_timeout;"; fi)
$(if [[ -n "$proxy_send_timeout" ]]; then echo "    proxy_send_timeout $proxy_send_timeout;"; fi)
    proxy_buffer_size $proxy_buffer_size;
    proxy_buffering $proxy_buffering;
    proxy_buffers $proxy_buffers;
    proxy_busy_buffers_size $proxy_busy_buffers_size;
    proxy_set_header Upgrade \$http_upgrade;
    proxy_set_header Connection \$http_connection;
    proxy_set_header Host \$http_host;
    proxy_set_header X-Request-Start \$msec;
    proxy_set_header X-Forwarded-Host \$host;

    proxy_set_header X-Forwarded-Prefix /${app_path}/;
    proxy_set_header X-Script-Name /${app_path};
$(if [[ -n "$proxy_x_forwarded_ssl" ]]; then echo "    proxy_set_header X-Forwarded-Ssl $proxy_x_forwarded_ssl;"; fi)
}

# Redirect from /${app_path} to /${app_path}/
location = /${app_path} {
    return 301 \$scheme://\$host/${app_path}/;
}

EOF
  done
}

fn-nginx-custom-computed-strip-path() {
  declare desc="get the computed strip-path value"
  declare APP="$1"

  local strip_path=$(fn-get-property --app "$APP" --computed "strip-path")
  if [[ -z "$strip_path" ]]; then
    echo "false"
  else
    echo "$strip_path"
  fi
}

generate_upstream_config_for_app() {
  local app="$1"
  local upstream_ports="$2"

  if [[ -z "$upstream_ports" ]]; then
    upstream_ports="5000"
  fi

  for upstream_port in $upstream_ports; do
    cat <<EOF
# Upstream for app: $app
upstream ${app}-${upstream_port} {
$(

listeners=$(plugn trigger network-get-listeners "$app" "web" | xargs)

if [[ -n "$listeners" ]]; then
  echo "$listeners" | while read -r listener; do
    local listener_ip=${listener%%:*}
    echo "  server ${listener_ip}:${upstream_port};"
  done
else

  docker ps --filter "name=${app}" --format "table {{.Names}}" | grep -v "NAMES" | head -5 | while read -r container_name; do
    if [[ -n "$container_name" ]]; then
      container_ip=$(docker inspect "$container_name" --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' 2>/dev/null || true)
      if [[ -n "$container_ip" ]]; then
        echo "  server ${container_ip}:${upstream_port};"
      fi
    fi
  done

  if ! docker ps --filter "name=${app}" --format "table {{.Names}}" | grep -v "NAMES" | head -1 > /dev/null; then
    echo "  server 172.17.0.1:${upstream_port};"
  fi
fi
)
}
EOF
  done
}
