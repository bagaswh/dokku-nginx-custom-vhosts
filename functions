#!/usr/bin/env bash
set -euo pipefail
[[ $DOKKU_TRACE ]] && set -x

_nginx_pre_flight_checks() {
  local APP="$1"
  if [[ "$(plugn trigger proxy-is-enabled "$APP")" != "true" ]]; then
    dokku_log_info1 "Nginx support is disabled for app ($APP)"
    if [[ -f "$DOKKU_ROOT/$APP/nginx.conf" ]]; then
      dokku_log_info1 "Deleting nginx.conf for $APP"
      rm -f "$DOKKU_ROOT/$APP/nginx.conf"
      rm -rf "$DOKKU_ROOT/$APP/nginx.conf.d"
      validate_nginx && restart_nginx >/dev/null
    fi
    return 1
  fi
  return 0
}

_nginx_resolve_primary_app() {
  local APP="$1"
  local ROOT_DOMAIN
  local ALL_APPS_FOR_DOMAIN=""
  local PRIMARY_APP_FOR_DOMAIN=""

  ROOT_DOMAIN="$(fn-nginx-path-computed-root-domain "$APP")"
  if [[ -z "$ROOT_DOMAIN" ]]; then
    ROOT_DOMAIN="$APP"
    dokku_log_info2 "No root domain configured, using app name: $ROOT_DOMAIN"
  fi

  local app_check
  for app_check in $(dokku_apps); do
    local app_check_root_domain
    app_check_root_domain="$(fn-nginx-path-computed-root-domain "$app_check")"
    if [[ -z "$app_check_root_domain" ]]; then
      app_check_root_domain="$app_check"
    fi

    if [[ "$app_check_root_domain" == "$ROOT_DOMAIN" ]] && [[ "$(plugn trigger proxy-is-enabled "$app_check")" == "true" ]]; then
      ALL_APPS_FOR_DOMAIN="$ALL_APPS_FOR_DOMAIN $app_check"
    fi
  done
  ALL_APPS_FOR_DOMAIN=$(echo "$ALL_APPS_FOR_DOMAIN" | xargs)

  for app_check in $ALL_APPS_FOR_DOMAIN; do
    local explicit_default
    explicit_default="$(fn-nginx-path-computed-default-app "$app_check")"
    if [[ -n "$explicit_default" ]] && [[ "$explicit_default" == "$app_check" ]]; then
      PRIMARY_APP_FOR_DOMAIN="$app_check"
      dokku_log_info2 "Found explicit default app: $PRIMARY_APP_FOR_DOMAIN"
      break
    fi
  done

  if [[ -z "$PRIMARY_APP_FOR_DOMAIN" ]]; then
    PRIMARY_APP_FOR_DOMAIN="$(echo "$ALL_APPS_FOR_DOMAIN" | tr ' ' '\n' | sort | head -1)"
    dokku_log_info2 "No explicit default app found for domain '$ROOT_DOMAIN'. Using alphabetically first app: '$PRIMARY_APP_FOR_DOMAIN'"
  fi

  echo "$PRIMARY_APP_FOR_DOMAIN"
}

_nginx_resolve_app_listeners_and_ports() {
  local APP="$1"
  local DOKKU_APP_LISTEN_PORT="$2"
  local DOKKU_APP_LISTEN_IP="$3"
  local proxy_port_map=""
  local PORT_MAP

  if [[ -z "$DOKKU_APP_LISTEN_PORT" ]] && [[ -z "$DOKKU_APP_LISTEN_IP" ]]; then
    _NGINX_LISTENERS="$(plugn trigger network-get-listeners "$APP" "web" 2>/dev/null | xargs || true)"

    if [[ -z "$_NGINX_LISTENERS" ]]; then
      dokku_log_info2 "No network listeners found, trying to detect from running containers..."
      local container_listeners=""
      local container_ip
      while read -r container_ip; do
        if [[ -n "$container_ip" ]]; then
          container_listeners="$container_listeners $container_ip:5000"
        fi
      done < <(docker ps --filter "label=com.dokku.app-name=$APP" --format "{{.Names}}" 2>/dev/null | head -5 | while read -r container_name; do
        docker inspect "$container_name" --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' 2>/dev/null || true
      done)

      if [[ -n "$container_listeners" ]]; then
        _NGINX_LISTENERS="$(echo "$container_listeners" | xargs)"
        dokku_log_info2 "Detected container listeners: $_NGINX_LISTENERS"
      fi
    fi

    if [[ -z "$_NGINX_LISTENERS" ]]; then
      dokku_log_info2 "No listeners detected, using default fallback"
      _NGINX_LISTENERS="172.17.0.1:5000"
    fi
    _NGINX_PASSED_LISTEN_IP_PORT="false"
  else
    _NGINX_PASSED_LISTEN_IP_PORT="true"
    _NGINX_LISTENERS="$DOKKU_APP_LISTEN_IP:$DOKKU_APP_LISTEN_PORT"
  fi

  plugn trigger ports-configure "$APP" 2>/dev/null || true
  _NGINX_PROXY_PORT=$(config_get "$APP" DOKKU_PROXY_PORT || echo "80")
  _NGINX_PROXY_SSL_PORT=$(config_get "$APP" DOKKU_PROXY_SSL_PORT || echo "443")

  _NGINX_UPSTREAM_PORTS=""
  while read -r PORT_MAP; do
    if [[ -n "$PORT_MAP" ]]; then
      local PROXY_UPSTREAM_SCHEME
      PROXY_UPSTREAM_SCHEME="$(awk -F ':' '{ print $1 }' <<<"$PORT_MAP")"
      if [[ "$PROXY_UPSTREAM_SCHEME" == "https" ]] && [[ "$(plugn trigger certs-exists "$APP")" != "true" ]]; then
        dokku_log_warn "Ignoring detected https port mapping without an accompanying ssl certificate (${PORT_MAP})"
        continue
      fi
      proxy_port_map="$proxy_port_map $PORT_MAP"
      local PROXY_UPSTREAM_PORT
      PROXY_UPSTREAM_PORT="$(awk -F ':' '{ print $3 }' <<<"$PORT_MAP")"
      if [[ "$(is_val_in_list "$PROXY_UPSTREAM_PORT" "$_NGINX_UPSTREAM_PORTS" " ")" == "false" ]]; then
        _NGINX_UPSTREAM_PORTS+="$PROXY_UPSTREAM_PORT "
      fi
    fi
  done < <(plugn trigger ports-get "$APP" 2>/dev/null || echo "http:80:5000")

  _NGINX_PORT_MAP="$(echo "$proxy_port_map" | xargs)"
  _NGINX_UPSTREAM_PORTS="$(echo "$_NGINX_UPSTREAM_PORTS" | xargs)"

  if [[ -z "$_NGINX_UPSTREAM_PORTS" ]]; then
    dokku_log_info2 "No upstream ports detected, using default port 5000"
    _NGINX_UPSTREAM_PORTS="5000"
    _NGINX_PORT_MAP="http:80:5000"
  fi

  dokku_log_info2 "Using listeners: $_NGINX_LISTENERS"
  dokku_log_info2 "Using upstream ports: $_NGINX_UPSTREAM_PORTS"
  dokku_log_info2 "Using port map: $_NGINX_PORT_MAP"
}

_nginx_gather_feature_support_vars() {
  local NGINX_LOCATION NGINX_VERSION
  NGINX_LOCATION=$(get_nginx_location)
  if [[ -z "$NGINX_LOCATION" ]]; then
    dokku_log_fail "Could not find nginx binary"
    exit 1
  fi
  NGINX_VERSION="$("$NGINX_LOCATION" -v 2>&1 | cut -d'/' -f 2)"

  _NGINX_FEATURE_SPDY_SUPPORTED="false"
  _NGINX_FEATURE_TLS13_SUPPORTED="$(is_tls13_available "$NGINX_VERSION")"
  _NGINX_FEATURE_HTTP2_SUPPORTED="$(is_http2_enabled "$NGINX_VERSION")"
  _NGINX_FEATURE_HTTP2_PUSH_SUPPORTED="$(is_http2_push_enabled "$NGINX_VERSION")"
  _NGINX_FEATURE_GRPC_SUPPORTED="$(is_grpc_enabled "$NGINX_VERSION")"
}

_nginx_gather_parameter_vars() {
  local APP="$1"
  _NGINX_PARAM_LOG_ROOT="$(fn-nginx-path-log-root)"
  _NGINX_PARAM_ACCESS_LOG_FORMAT="$(fn-nginx-path-computed-access-log-format "$APP")"
  _NGINX_PARAM_ACCESS_LOG_PATH="$(fn-nginx-path-computed-access-log-path "$APP")"
  _NGINX_PARAM_ERROR_LOG_PATH="$(fn-nginx-path-computed-error-log-path "$APP")"
  _NGINX_PARAM_CLIENT_BODY_TIMEOUT="$(fn-nginx-path-computed-client-body-timeout "$APP")"
  _NGINX_PARAM_CLIENT_HEADER_TIMEOUT="$(fn-nginx-path-computed-client-header-timeout "$APP")"
  _NGINX_PARAM_CLIENT_MAX_BODY_SIZE="$(fn-nginx-path-computed-client-max-body-size "$APP")"
  _NGINX_PARAM_KEEPALIVE_TIMEOUT="$(fn-nginx-path-computed-keepalive-timeout "$APP")"
  _NGINX_PARAM_LINGERING_TIMEOUT="$(fn-nginx-path-computed-lingering-timeout "$APP")"
  _NGINX_PARAM_PROXY_CONNECT_TIMEOUT="$(fn-nginx-path-computed-proxy-connect-timeout "$APP")"
  _NGINX_PARAM_PROXY_READ_TIMEOUT="$(fn-nginx-path-computed-proxy-read-timeout "$APP")"
  _NGINX_PARAM_PROXY_SEND_TIMEOUT="$(fn-nginx-path-computed-proxy-send-timeout "$APP")"
  _NGINX_PARAM_SEND_TIMEOUT="$(fn-nginx-path-computed-send-timeout "$APP")"
  _NGINX_PARAM_PROXY_BUFFER_SIZE="$(fn-nginx-path-computed-proxy-buffer-size "$APP")"
  _NGINX_PARAM_PROXY_BUFFERING="$(fn-nginx-path-computed-proxy-buffering "$APP")"
  _NGINX_PARAM_PROXY_BUFFERS="$(fn-nginx-path-computed-proxy-buffers "$APP")"
  _NGINX_PARAM_PROXY_BUSY_BUFFERS_SIZE="$(fn-nginx-path-computed-proxy-busy-buffers-size "$APP")"
  _NGINX_PARAM_BIND_ADDRESS_IP4="$(fn-nginx-path-computed-bind-address-ipv4 "$APP")"
  _NGINX_PARAM_BIND_ADDRESS_IP6="$(fn-nginx-path-computed-bind-address-ipv6 "$APP")"
  _NGINX_PARAM_UNDERSCORE_IN_HEADERS="$(fn-nginx-path-computed-underscore-in-headers "$APP")"

  # PERBAIKAN: Berikan fallback values untuk header yang bermasalah
  _NGINX_PARAM_X_FORWARDED_FOR="$(fn-nginx-path-computed-x-forwarded-for-value "$APP")"
  _NGINX_PARAM_X_FORWARDED_PORT="$(fn-nginx-path-computed-x-forwarded-port-value "$APP")"
  _NGINX_PARAM_X_FORWARDED_PROTO="$(fn-nginx-path-computed-x-forwarded-proto-value "$APP")"
  _NGINX_PARAM_X_FORWARDED_SSL="$(fn-nginx-path-computed-x-forwarded-ssl "$APP")"

  # Set fallback values jika kosong
  [[ -z "$_NGINX_PARAM_X_FORWARDED_FOR" ]] && _NGINX_PARAM_X_FORWARDED_FOR="\$proxy_add_x_forwarded_for"
  [[ -z "$_NGINX_PARAM_X_FORWARDED_PORT" ]] && _NGINX_PARAM_X_FORWARDED_PORT="\$server_port"
  [[ -z "$_NGINX_PARAM_X_FORWARDED_PROTO" ]] && _NGINX_PARAM_X_FORWARDED_PROTO="\$scheme"
  [[ -z "$_NGINX_PARAM_X_FORWARDED_SSL" ]] && _NGINX_PARAM_X_FORWARDED_SSL="off"

  _NGINX_PARAM_STRIP_PATH="$(fn-nginx-path-computed-strip-path "$APP")"
}

_nginx_gather_ssl_vars() {
  local APP="$1"
  local ROOT_DOMAIN="$2"
  local VHOST_PATH="$DOKKU_ROOT/$APP/VHOST"
  local IS_APP_VHOST_ENABLED=true
  local NONSSL_VHOSTS
  local SSL_HOSTNAME
  local SSL_HOSTNAME_REGEX
  local SSL_VHOSTS
  local host

  _NGINX_SSL_ENABLED=false
  _NGINX_SSL_INUSE=""
  _NGINX_SSL_SERVER_NAME=""
  _NGINX_SCHEME="http"

  if [[ "$(plugn trigger certs-exists "$APP")" == "true" ]]; then
    _NGINX_SSL_ENABLED=true
    _NGINX_SSL_INUSE=true
    _NGINX_SCHEME="https"
  fi

  plugn trigger domains-vhost-enabled "$APP" 2>/dev/null || IS_APP_VHOST_ENABLED=false
  NONSSL_VHOSTS=$(plugn trigger domains-list "$APP" 2>/dev/null || echo "$ROOT_DOMAIN")
  _NGINX_NOSSL_SERVER_NAME=$(echo "$NONSSL_VHOSTS" | xargs)

  if [[ "$_NGINX_SSL_ENABLED" == "true" ]]; then
    validate_ssl_domains "$APP"
    SSL_HOSTNAME=$(get_ssl_hostnames "$APP")
    SSL_HOSTNAME_REGEX=$(echo "$SSL_HOSTNAME" | xargs | sed 's|\.|\\.|g' | sed 's/\*/\[^\.\]\*/g' | sed 's/ /|/g')

    if [[ "$IS_APP_VHOST_ENABLED" == "true" ]]; then
      SSL_VHOSTS=$(grep -E "^${SSL_HOSTNAME_REGEX}$" "$VHOST_PATH" 2>/dev/null || true)
    else
      SSL_VHOSTS=$(<"$DOKKU_ROOT/VHOST" 2>/dev/null || echo "$ROOT_DOMAIN")
    fi

    for host in $SSL_VHOSTS; do
      if [[ ! $_NGINX_NOSSL_SERVER_NAME =~ (^|[[:space:]])$host($|[[:space:]]) ]]; then
        _NGINX_SSL_SERVER_NAME="${host}${_NGINX_SSL_SERVER_NAME:+ $_NGINX_SSL_SERVER_NAME}"
      fi
    done
  fi
}

_nginx_generate_secondary_app_configs() {
  local PRIMARY_APP="$1"
  local WORK_DIR="$2"
  local ALL_APPS_FOR_DOMAIN
  local other_app

  ALL_APPS_FOR_DOMAIN=$( (
    local ROOT_DOMAIN
    ROOT_DOMAIN="$(fn-nginx-path-computed-root-domain "$PRIMARY_APP")"
    if [[ -z "$ROOT_DOMAIN" ]]; then
      ROOT_DOMAIN="$PRIMARY_APP"
    fi

    local app_check
    for app_check in $(dokku_apps); do
      local app_check_root_domain
      app_check_root_domain="$(fn-nginx-path-computed-root-domain "$app_check")"
      if [[ -z "$app_check_root_domain" ]]; then
        app_check_root_domain="$app_check"
      fi

      if [[ "$app_check_root_domain" == "$ROOT_DOMAIN" ]] && [[ "$(plugn trigger proxy-is-enabled "$app_check")" == "true" ]]; then
        echo "$app_check"
      fi
    done
  ) | xargs)

  rm -f "$DOKKU_ROOT/$PRIMARY_APP/nginx.conf.d/"*.conf 2>/dev/null || true
  mkdir -p "$DOKKU_ROOT/$PRIMARY_APP/nginx.conf.d"

  for other_app in $ALL_APPS_FOR_DOMAIN; do
    if [[ "$other_app" != "$PRIMARY_APP" ]]; then
      dokku_log_info2 "Merging config for $other_app..."
      local other_app_path
      other_app_path="$(fn-nginx-path-computed-app-path "$other_app")"
      local other_upstream_ports=""
      local PORT_MAP

      while read -r PORT_MAP; do
        if [[ -n "$PORT_MAP" ]]; then
          local other_upstream_port
          other_upstream_port="$(awk -F ':' '{ print $3 }' <<<"$PORT_MAP")"
          other_upstream_ports="$other_upstream_ports $other_upstream_port"
        fi
      done < <(plugn trigger ports-get "$other_app" 2>/dev/null || echo "http:80:5000")
      other_upstream_ports="$(echo "$other_upstream_ports" | xargs)"

      if [[ -z "$other_upstream_ports" ]]; then
        other_upstream_ports="5000"
      fi

      generate_location_config_for_app "$other_app" "$other_app_path" "$other_upstream_ports" "$WORK_DIR" >"$DOKKU_ROOT/$PRIMARY_APP/nginx.conf.d/location-${other_app}.conf"
      generate_upstream_config_for_app "$other_app" "$other_upstream_ports" >"$DOKKU_ROOT/$PRIMARY_APP/nginx.conf.d/upstream-${other_app}.conf"
    fi
  done

  for other_app in $ALL_APPS_FOR_DOMAIN; do
    if [[ "$other_app" != "$PRIMARY_APP" ]] && [[ -f "$DOKKU_ROOT/$other_app/nginx.conf" ]]; then
      dokku_log_info2 "Deleting conflicting nginx.conf from secondary app $other_app"
      rm -f "$DOKKU_ROOT/$other_app/nginx.conf"
      rm -rf "$DOKKU_ROOT/$other_app/nginx.conf.d"
    fi
  done
}

_nginx_process_sigil_template() {
  local APP="$1"
  local WORK_DIR="$2"
  local DOKKU_APP_LISTEN_PORT="$3"
  local DOKKU_APP_LISTEN_IP="$4"
  local NGINX_TEMPLATE_NAME="nginx.conf.sigil"
  local NGINX_TEMPLATE
  local NGINX_TEMPLATE_SOURCE
  local CUSTOM_NGINX_TEMPLATE="$WORK_DIR/$NGINX_TEMPLATE_NAME"
  local NGINX_CONF
  local SIGIL_PARAMS
  local line PROC_TYPE LISTENERS UPP_PROC_TYPE
  local ROOT_DOMAIN APP_PATH

  NGINX_CONF=$(mktemp --tmpdir="${WORK_DIR}" "nginx.conf.XXXXXX")

  if get_custom_nginx_template "$APP" "$CUSTOM_NGINX_TEMPLATE"; then
    dokku_log_info1 'Overriding default nginx.conf with detected nginx.conf.sigil'
    NGINX_TEMPLATE="$CUSTOM_NGINX_TEMPLATE"
    NGINX_TEMPLATE_SOURCE="app-supplied"
  else
    dokku_log_info2 'No custom nginx.conf.sigil found, using built-in template.'
    NGINX_TEMPLATE="$_DIR/templates/$NGINX_TEMPLATE_NAME"
    NGINX_TEMPLATE_SOURCE="built-in"
  fi

  if [[ -z "$NGINX_TEMPLATE" ]] || [[ ! -f "$NGINX_TEMPLATE" ]]; then
    dokku_log_fail "FATAL: Nginx template could not be found."
    return 1
  fi

  ROOT_DOMAIN="$(fn-nginx-path-computed-root-domain "$APP")"
  if [[ -z "$ROOT_DOMAIN" ]]; then
    ROOT_DOMAIN="$APP"
  fi
  APP_PATH="$(fn-nginx-path-computed-app-path "$APP")"

  eval "$(config_export app "$APP" 2>/dev/null || true)"
  SIGIL_PARAMS=(-f "$NGINX_TEMPLATE" APP="$APP" DOKKU_ROOT="$DOKKU_ROOT"
    NOSSL_SERVER_NAME="$_NGINX_NOSSL_SERVER_NAME"
    DOKKU_APP_LISTENERS="$_NGINX_LISTENERS"
    DOKKU_LIB_ROOT="$DOKKU_LIB_ROOT"
    PASSED_LISTEN_IP_PORT="${_NGINX_PASSED_LISTEN_IP_PORT:-}"
    SPDY_SUPPORTED="$_NGINX_FEATURE_SPDY_SUPPORTED"
    TLS13_SUPPORTED="$_NGINX_FEATURE_TLS13_SUPPORTED"
    HTTP2_SUPPORTED="$_NGINX_FEATURE_HTTP2_SUPPORTED"
    NGINX_LOG_ROOT="$_NGINX_PARAM_LOG_ROOT"
    NGINX_ACCESS_LOG_FORMAT="$_NGINX_PARAM_ACCESS_LOG_FORMAT"
    NGINX_ACCESS_LOG_PATH="$_NGINX_PARAM_ACCESS_LOG_PATH"
    NGINX_ERROR_LOG_PATH="$_NGINX_PARAM_ERROR_LOG_PATH"
    NGINX_BIND_ADDRESS_IP4="$_NGINX_PARAM_BIND_ADDRESS_IP4"
    NGINX_BIND_ADDRESS_IP6="$_NGINX_PARAM_BIND_ADDRESS_IP6"
    HTTP2_PUSH_SUPPORTED="$_NGINX_FEATURE_HTTP2_PUSH_SUPPORTED"
    GRPC_SUPPORTED="$_NGINX_FEATURE_GRPC_SUPPORTED"
    DOKKU_APP_LISTEN_PORT="$DOKKU_APP_LISTEN_PORT" DOKKU_APP_LISTEN_IP="$DOKKU_APP_LISTEN_IP"
    APP_SSL_PATH="$DOKKU_ROOT/$APP/tls" SSL_INUSE="$_NGINX_SSL_INUSE" SSL_SERVER_NAME="$_NGINX_SSL_SERVER_NAME"
    CLIENT_BODY_TIMEOUT="$_NGINX_PARAM_CLIENT_BODY_TIMEOUT"
    CLIENT_HEADER_TIMEOUT="$_NGINX_PARAM_CLIENT_HEADER_TIMEOUT"
    CLIENT_MAX_BODY_SIZE="$_NGINX_PARAM_CLIENT_MAX_BODY_SIZE"
    KEEPALIVE_TIMEOUT="$_NGINX_PARAM_KEEPALIVE_TIMEOUT"
    LINGERING_TIMEOUT="$_NGINX_PARAM_LINGERING_TIMEOUT"
    PROXY_CONNECT_TIMEOUT="$_NGINX_PARAM_PROXY_CONNECT_TIMEOUT"
    PROXY_READ_TIMEOUT="$_NGINX_PARAM_PROXY_READ_TIMEOUT"
    PROXY_SEND_TIMEOUT="$_NGINX_PARAM_PROXY_SEND_TIMEOUT"
    SEND_TIMEOUT="$_NGINX_PARAM_SEND_TIMEOUT"
    PROXY_BUFFER_SIZE="$_NGINX_PARAM_PROXY_BUFFER_SIZE"
    PROXY_BUFFERING="$_NGINX_PARAM_PROXY_BUFFERING"
    PROXY_BUFFERS="$_NGINX_PARAM_PROXY_BUFFERS"
    PROXY_BUSY_BUFFERS_SIZE="$_NGINX_PARAM_PROXY_BUSY_BUFFERS_SIZE"
    NGINX_UNDERSCORE_IN_HEADERS="$_NGINX_PARAM_UNDERSCORE_IN_HEADERS"
    NGINX_PORT="$_NGINX_PROXY_PORT" NGINX_SSL_PORT="$_NGINX_PROXY_SSL_PORT"
    PROXY_PORT="$_NGINX_PROXY_PORT" PROXY_SSL_PORT="$_NGINX_PROXY_SSL_PORT"
    PROXY_PORT_MAP="$_NGINX_PORT_MAP" PROXY_UPSTREAM_PORTS="$_NGINX_UPSTREAM_PORTS"
    PROXY_X_FORWARDED_FOR="$_NGINX_PARAM_X_FORWARDED_FOR"
    PROXY_X_FORWARDED_PORT="$_NGINX_PARAM_X_FORWARDED_PORT"
    PROXY_X_FORWARDED_PROTO="$_NGINX_PARAM_X_FORWARDED_PROTO"
    PROXY_X_FORWARDED_SSL="$_NGINX_PARAM_X_FORWARDED_SSL"
    APP_PATH="$APP_PATH"
    ROOT_DOMAIN="$ROOT_DOMAIN"
    DEFAULT_APP="$APP"
    STRIP_PATH="$_NGINX_PARAM_STRIP_PATH")

  while read -r line || [[ -n "$line" ]]; do
    if [[ -n "$line" ]]; then
      PROC_TYPE=${line%%=*}
      LISTENERS="$(plugn trigger network-get-listeners "$APP" "$PROC_TYPE" 2>/dev/null | xargs || true)"
      UPP_PROC_TYPE="${PROC_TYPE^^}"
      UPP_PROC_TYPE="${UPP_PROC_TYPE//-/_}"
      SIGIL_PARAMS+=("DOKKU_APP_${UPP_PROC_TYPE}_LISTENERS=$LISTENERS")
    fi
  done < <(plugn trigger ps-current-scale "$APP" 2>/dev/null || echo "web=1")

  xargs -i echo "-----> Configuring {}...(using $NGINX_TEMPLATE_SOURCE template)" <<<"$(echo "${_NGINX_SSL_SERVER_NAME:-}" "${_NGINX_NOSSL_SERVER_NAME}" | tr ' ' '\n' | sort -u)"

  dokku_log_info2 "Generating nginx configuration..."
  if ! sigil "${SIGIL_PARAMS[@]}" | cat -s >"$NGINX_CONF"; then
    dokku_log_fail "Failed to generate nginx configuration using sigil"
    return 1
  fi

  echo "$NGINX_CONF"
}

_nginx_finalize_config_and_reload() {
  local APP="$1"
  local GENERATED_CONF_PATH="$2"
  local DOKKU_APP_LISTEN_PORT="$3"
  local DOKKU_APP_LISTEN_IP="$4"

  dokku_log_info1 "Creating $_NGINX_SCHEME nginx.conf for $APP"
  mv "$GENERATED_CONF_PATH" "$DOKKU_ROOT/$APP/nginx.conf"

  fn-nginx-path-vhosts-manage-hsts "$APP" "$_NGINX_SSL_INUSE"
  plugn trigger nginx-path-pre-reload "$APP" "$DOKKU_APP_LISTEN_PORT" "$DOKKU_APP_LISTEN_IP" 2>/dev/null || true

  dokku_log_verbose "Reloading nginx-path"
  validate_nginx && restart_nginx >/dev/null
}

nginx_build_config() {
  declare desc="build nginx config to proxy app containers using sigil"
  declare APP="$1"
  declare DOKKU_APP_LISTEN_PORT="${2:-}"
  declare DOKKU_APP_LISTEN_IP="${3:-}"
  local PRIMARY_APP
  local WORK_DIR
  local GENERATED_CONF_PATH

  if ! _nginx_pre_flight_checks "$APP"; then
    return
  fi

  PRIMARY_APP=$(_nginx_resolve_primary_app "$APP")

  if [[ "$APP" != "$PRIMARY_APP" ]]; then
    dokku_log_info2 "Domain is managed by $PRIMARY_APP. Building its config instead..."
    nginx_build_config "$PRIMARY_APP" "$DOKKU_APP_LISTEN_PORT" "$DOKKU_APP_LISTEN_IP"
    return
  fi

  dokku_log_info1 "Creating primary configuration for domain (managed by $APP)..."

  WORK_DIR=$(mktemp -d "/tmp/dokku-${DOKKU_PID}-${FUNCNAME[0]}.XXXXXX")
  trap "rm -rf '$WORK_DIR' >/dev/null" RETURN INT TERM EXIT

  if ! (is_deployed "$APP" 2>/dev/null); then
    dokku_log_warn_quiet "App $APP may not be fully deployed, but generating nginx config anyway"
  fi

  _nginx_gather_feature_support_vars
  _nginx_gather_parameter_vars "$APP"

  local ROOT_DOMAIN
  ROOT_DOMAIN="$(fn-nginx-path-computed-root-domain "$APP")"
  if [[ -z "$ROOT_DOMAIN" ]]; then
    ROOT_DOMAIN="$APP"
  fi
  _nginx_gather_ssl_vars "$APP" "$ROOT_DOMAIN"

  _nginx_resolve_app_listeners_and_ports "$APP" "$DOKKU_APP_LISTEN_PORT" "$DOKKU_APP_LISTEN_IP"
  _nginx_generate_secondary_app_configs "$APP" "$WORK_DIR"

  GENERATED_CONF_PATH=$(_nginx_process_sigil_template "$APP" "$WORK_DIR" "$DOKKU_APP_LISTEN_PORT" "$DOKKU_APP_LISTEN_IP")

  _nginx_finalize_config_and_reload "$APP" "$GENERATED_CONF_PATH" "$DOKKU_APP_LISTEN_PORT" "$DOKKU_APP_LISTEN_IP"
}
